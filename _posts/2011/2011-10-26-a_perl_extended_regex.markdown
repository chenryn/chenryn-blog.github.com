---
layout: post
title: 一个perl扩展正则表达式
date: 2011-10-26
category: perl
---

今天傍晚，莫言在Q群里贴了一个他写的正则表达式，回来翻了翻perlre文档，基本算是看懂，赶紧记录下来：
{% highlight perl %}my $ip = "192.168.0.1|192.168.0.2|192.168.0.1";
if ( $ip =~ /
    ^
    (?:
        ((?:\d{1,3}\.){3}\d{1,3})
        (?=
            (?:
                \|(?!\1)(?1)
            )*
            \z
        )
        \|
    )*
    (?1)
    $
    /x ) {
    print "match\n";
}{% endhighlight %}
根据<a href="http://perldoc.perl.org/perlre.html" title="perlre文档" target="_blank">perlre文档</a>的说明，一点一点解释。

1. 首先是/x，用这个来去除regex里的空格，不然的话写在一行太难看懂了；
2. 然后是^，表示从最开头开始；
3. 然后是(?:，这个表示本括号不记入反向引用$&中；
4. 然后是((?:\d{1,3}\.){3}\d{1,3})，同样里面一个(?:，也就是说这一行匹配一个ip，并计为$1；
5. 然后是(?=，这个表示在上面那行ip的正则后面必须出现符合本括号定义，同样也不计入$&（术语叫"零宽肯定前向断言"是吧？）；
6. 然后一个隔开ip的|；
7. 然后是(?!，这个表示本括号内的东西绝对不能出现，同样也不计入$&（术语叫"零宽否定前向断言"是吧？）；
8. 然后是\1，这个就是前面捕获的$1，跟上行解释的断言合在一起，就是|后面不能有和前面匹配的ip重复；
9. 然后是(?1，这个表示前面捕获$1的正则表达式，也就是不重复ip的情况下，继续捕获新ip；
10. 然后是)*，这个)闭合到|前面的(?:，也就是说|ip可以重复多个；
11. 然后是\z，这个是字符串边界，相当于单行里$的作用，在本例中可以互换，用在这里，就是为了让(?!\1)的检查一直执行到最后；
12. 然后是)，闭合(?=；
13. 然后是\|和)*，这里闭合到^(，表示符合不重复ip条件的ip|格式不断正则匹配；
14. 然后是(?1)$，定义最后一个ip，使用和$1相同的正则，也就是字符串至少要有一个ip。

OK，解释完毕。其实，从后往前看，反而清晰一些~~

另：perlre中在(??{CODE})段的表述中有如下一段话“In perl 5.12.x and earlier, because the regex engine was not re-entrant, delayed code could not safely invoke the regex engine either directly with "m//" or "s///"), or indirectly with functions such as "split".”，而(?R)和(??{CODE})做的是类似而简单的任务，所以如果linux发行版里带的perl版本不够高的话，这里就不能用(?1)的简单写法，需要自己再写一遍了。

可以这么判断：
{% highlight perl %}
my $re = $^V lt v5.14 ? '(?:\d{1,3}\.?){4}' : '(?1)';
my $ip = "192.168.0.1|192.168.0.2|192.168.0.3|192.168.0.4|192.168.0.5";
if ( $ip =~ m/
    ^
    (?:
        ((?:\d{1,3}\.?){4})
        (?=
            (?:
                \|(?!\1)$re
            )*
            \z
        )
        \|
    )*
    $re
    $
    /x ) {
    print "$1 match\n";
}
{% endhighlight %}

