---
layout: post
title: perl内置变量
date: 2010-04-22
category: perl
---

$_ 默认输入/模式搜索空间，常用于-f -d测试、print unlink函数、m// s/// tr///匹配、foreach while循环

@_ 传递给函数的所有参数

$&/$`/$' 分别是上次匹配成功（时/前/后）的字符串（这三个变量会导致效率显著降低）
local $_ = 'abcdefghi';
/def/;
print "$`:$&:$'n";         # prints abc:def:ghi

$+ 上次搜索中最后一个括号匹配的文本
/Version: (.*)|Revision: (.*)/ && ($rev = $+);

$^N 上次搜索中最后闭合的组所匹配的文本（可能嵌套）
(?:(...)(?{ $var = $^N }));    #这样可以省去计算括号个数

$* 匹配模式优化（即当其==0时，perl认为字符串仅为一行(n)，推荐使用/s和/m代替此变量）

$. 相当于awk中的NR，但如果文件句柄被close()，$.就会复位，相当于FNR

$/ 相当于RS，正常情况设置为字符串；设置为undef即一口气全读入；设置为整数标量时则读入小于该整数的记录而不是行；一些小文件，可以采用$data = do { local $/;<FH>; };单行命令读入，就是这个原理。

$ 相当于ORS

$, 相当于OFS

$" 同$,不过用于向用"引起的字符串插入数据的时候

$; 模拟多维数组时下标的分隔符。
$foo{$a,$b,$c};
$foo{join($;, $a, $b, $c)};        #两者相当

$| 设置为非零值时，强制刷新每次输出缓存；在向管道和套接字输出时设置该变量

$# 相当于OFMT，不过awk里是%.6g，perl里是%*n*g，*n*取决于OS上float.h 中 DBL_DIG 宏的值（不建议使用该变量）

@-/@+ 分别是模式匹配时，每次成功匹配字符串开始和结束处的偏移量

在对某个变量 $var 进行匹配后：
$` 和 "substr($var, 0, $-[0])" 相同
$&amp; 和 "substr($var, $-[0], $+[0] - $-[0])" 相同
$' 和 "substr($var, $+[0])" 相同
$1 和 "substr($var, $-[1], $+[1] - $-[1])" 相同
$2 和 "substr($var, $-[2], $+[2] - $-[2])" 相同

$#+是最近成功匹配了多少个组

$[ 数组中的第一个元素/字符串中第一个字符的索引号，默认为0（最好不要改）

$] perl解释器版本（5.001格式）

$^V perl解释器版本（5.8.8格式）

$^T 程序运行时间（UNIX秒）

$$ perl脚本的运行进程号

$< perl脚本的运行实际用户

$> perl脚本的运行有效用户

$( perl脚本的运行实际用户组

$) perl脚本的运行有效用户组

$0 当前程序名

$@/$!/$^E/$? 分别是perl解释器、C库、操作系统、外部程序检测到的错误
{% highlight perl %}
eval q{
    open my $pipe, "/cdrom/install |" or die $!;
    my @res = <$pipe>;
    close $pipe or die "bad pipe: $?, $!";
};
{% endhighlight %}
在需要 "eval" 的字符串没有通过编译(若 "open" 或 "close"导入的原型错误则可能发生)或者 Perl 代码在执行过程中 die() 掉，则 $@变量会被设置。这些情况下 $@ 的值是编译错误信息或 "die" 的参数(其中会内插 $! 和 $?)。(另见 Fatal)    
上面的 eval() 表达式执行后，open()、"<PIPE>" 和 "close" 被翻译成对 C运行库的调用，继而 进入操作系统内核。若其中某个调用失败，则 $! 会设置为C 库的 "errno" 值。

在少数操作系统下，$^E 可能含有更详细的错误指示，例如“CDROM仓门没有关闭”。不支持扩展错误 信息的系统只是将 $^E 设置为和 $!一样的值。

最后，$? 在外部程序 /cdrom/install 失败时设置为非 0 值。高8位反映出该程序遇到的特定错误 条件(程序的 exit() 值)，低8位反映失败方式，例如信号致死或核心转储，细节参见 wait(2)。对比仅在检测到错误条件时才设置的 $! 和 $^E，变量 $? 在每个 "wait" 或管道"close" 时都会 设置并冲掉旧值。这一行为更接近 $@，后者在每次 eval()后总是在失败时设置并在成功时清除。

更多细节请分别参见 $@、$!、$^E 和 $? 各自的说明。
